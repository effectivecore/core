

                       ○○○○   ○○○○
                     ○○○○○  ○○○○○○
                    ○○○    ○○○
        ○○○○○○○     ○○○○○○○○○○○○○○  ○○○○○○○      ○○○○○○○     ○○ ○○○   ○○○○○○○
      ○○○○   ○○○○   ○○○○○○○○○○○○  ○○○     ○○○  ○○○     ○○○   ○○○    ○○○     ○○○
     ○○○       ○○○  ○○○    ○○○   ○○           ○○         ○○  ○○    ○○         ○○
    ○○○○○○○○○○○○○○  ○○○    ○○○  ○○           ○○           ○○ ○○   ○○○○○○○○○○○○○○
     ○○○            ○○○    ○○○   ○○           ○○         ○○  ○○    ○○
      ○○○○   ○○○○   ○○○    ○○○    ○○○     ○○○  ○○○     ○○○   ○○     ○○○     ○○○
        ○○○○○○○     ○○○    ○○○      ○○○○○○○      ○○○○○○○     ○○       ○○○○○○○
                  ○○○○   ○○○○
                ○○○○   ○○○○


О ПРОЕКТЕ
=====================================================================

effcore - система нового поколения, разработанная в начале 20-ых годов.
Вобрала в себя все новые технологии Web 2.0/3.0 включая HTML5, CSS3, JS ES6,
IP v6, SVG, SMIL, UTF8, UTC.

Целевое назначение - использование в качестве инструмента для построения
сайтов простыми пользователями, а также в качестве инструмента для
разработки сайтов и порталов профессиональными веб-разработчиками.

Была разработана с нуля. Её главный принцип - полное отсутствие
стороннего кода (для исключения правовых претензий, а также любых
других ограничений, связанных с заимствованием),
а также сторонних идей (для поиска новых инновационных решений).

Толчком к созданию системы послужила массовая деградация в развитии
OpenSource проектов. Если рассмотреть данную ситуацию, то можно увидеть,
что разработчиками таких проектов являются люди разного уровня подготовки,
расположенные в разных частях планеты. Несогласованность в их действиях, а
также разные взгляды на решения в проекте является лишь частью проблемы.
Второй существенный недостаток - это экстенсивный путь развития кода таких
проектов в противовес интенсивному, т.е. вместо того, чтобы создавать
собственный код, они, как правило, берут очередную библиотеку, написанную
непонятно кем и непонятно где и пытаются совместить её с группой таких же
библиотек, никак между собой не согласованных и имеющих, как правило,
избыточный и не до конца протестированный функционал.
Как следствие, в результате получается набор непонятных и
не согласованных библиотек с плохо протестированным избыточным
функционалом, который постоянно растет в объёме.
К сожалению многие разработчики "погрязли" в таком коде
и пытаются отрицать очевидные вещи.

Основной упор в системе сделан на получение максимальной производительности.
В качестве оценочных критериев было принято простое и понятное условие:
система, установленная на хостинге с самым дешёвым тарифным планом,
но соответствующего минимальным требованиям установки (от ≈3$ в месяц),
должна генерировать главную страницу за время 0,002 секунды (с включенным
OPcache) или 0,02 секунды (с выключенным OPcache), что в первом случае
позволяет обслуживать до ≈500 клиентов в секунду, а во втором до ≈50 (без
учёта параллельной загрузки подключаемого контента).

Архитектура выполнена по классической схеме MVC.
В тоже время является гибридной системой из NoSQL и SQL хранилищ и набора
классов/классов-паттернов.

Код системы адаптирован под повторное использование.
Система состоит из множества маленьких классов/классов-паттернов,
содержащих в себе в среднем от 3 до 15 методов,
состоящих в среднем из 3-7 строк кода.

Благодаря "матричному" стилю вёрстки кода его восприятие существенно
облегчается (в некоторых местах напоминает синтаксис Python), а
грамотное расположение файлов в системе позволяет определить их
назначение не прибегая к какой либо документации (в каждом модуле
всё необходимое для frontend разработки хранится в директории frontend,
а для backend разработки - в директории backend).
Также всё, что казалось сложным, было отвергнуто или переделано.
Каждая функция итеративно совершенствовалась от 3 до 10 раз.
Функциональное тестирование выполнялось на всём множестве
комбинаторных перестановок.

Имеет встроенный парсер и загрузчик классов PSR-0, благодаря чему
для добавления новой библиотеки (набора классов) достаточно поместить
содержащие их файлы на веб-сервер и сбросить кэш, после чего они
становятся доступными из любого места системы.
В состав системы входит страница с UML диаграммой всех классов
и ссылкой для загрузки JSON файла с описанием классов в формате
программы StarUML.



Безопасность
=====================================================================

Также немаловажным фактором в системе стала безопасность.
В качестве решений для повышения уровня безопасности были использованы:
- возможность работы без JS;
- подписанные ключом пользовательские сессии;
- подписанные ключом валидационные идентификаторы формы;
- использование препарированных SQL запросов;
- фильтрация данных, вводимых пользователем в поля формы;
- фильтрация аргументов URL;
- единая точка входа любого http запроса (single entry point),
  как результат - отсутсвие негативных воздействий при неверной настройке
  веб-сервера (.htaccess, web.config);
- возможность создания нового типа файла с полным контролем доступа;
- возможность получения хеша сборки страницы в консоле системы;
- базовый модуль CAPTCHA.

Детерминизм в работе системы - еще один немаловажный фактор.
При одних и тех же входных параметрах должен выдавать один и тот же результат
вне зависимости от платформы и как результат - полный отказ от функций,
работа которых зависит от окружения (например, setlocale и другие).



Ядро: NoSQL
=====================================================================

Любой экземпляр класса и другие NoSQL-данные могут быть описаны в текстовом
формате в файле вида *.data, подобном YAML, однако имеющем более строгие
правила такие как "каждая строка может содержать только одну
фразу вида "ключ: значение", что удобно для контроля изменений
в коде (любое изменение одного ключа или значения будет выделяться
в git diff только одной строкой), а также существенно ускоряет
парсинг таких файлов.
Ниже приведён пример *.data файла.

    demo
      object_1|class_name
        property_1: value 1
        property_2: value 2 …
        property_N: value N
      array_1
      - item_1: value 1
      - item_2: value 2 …
      - item_N: value N

При этом и объекты (экземпляры классов-паттернов) и массивы могут иметь
любые уровни вложенности и содержать в себе любые другие объекты или
массивы.

После парсинга *.data файлов результат преобразуется
в PHP код (единое дерево объектов - экземпляров классов-патернов),
после чего сохраняется в файлы cache-*.php директории dynamic/cache
в отдельном файле для каждого вида сущности, как показано в примере ниже:
- dynamic/cache/data--blocks.php
- dynamic/cache/data--breadcrumbs.php
- dynamic/cache/data--file_types.php
и так далее.

Описанный выше пример будет преобразован в PHP файл следующего вида: 

    namespace effcore {
      cache::$data['demo'] = new \stdClass;
      cache::$data['demo']->object_1 = new class_name;
      cache::$data['demo']->object_1->property_1 = 'value 1';
      cache::$data['demo']->object_1->property_2 = 'value 2';
      cache::$data['demo']->object_1->property_N = 'value N';
      cache::$data['demo']->array_1['item_1'] = 'value 1';
      cache::$data['demo']->array_1['item_2'] = 'value 2';
      cache::$data['demo']->array_1['item_N'] = 'value N';
    }

Такая архитектура позволяет получать доступ к NoSQL данным настолько быстро,
насколько это возможно. При использовании PHP модуля OPcache скорость доступа
может возрасти от 2 до 3 раз.
По сути для доступа к NoSQL данным достаточно загрузить PHP файл
определенной сущности и данные станут доступны сразу же после загрузки.

Таким образом ядро системы составляет вышеупомянутый набор классов-паттернов,
а также NoSQL хранилище, кэш которого представлен в виде PHP кода,
содержащего экземпляры этих классов в древовидной форме с любым уровнем
вложенности и неограниченных по своей структуре.



Кеширование
=====================================================================

Благодаря своей архитектуре в проектах среднего уровня не требуется кеширование.
Для больших проектов кеширование обычно выполняется сторонними средствами
веб-сервера, что изначально предполагается автором.



SQL
=====================================================================

В качестве SQL хранилища могут быть использованы MySQL и SQLite.
Подключение к хранилищу и выборка данных осуществляется лишь по требованию.
Отказ SQL хранилища не приведет к выдаче ошибки, а лишь сделает недоступными
часть возможностей (например, отключатся сессии и вход в систему,
а на страницах с выборками будет показано "0 результатов").
Поддерживаются:
- транзакции;
- внешние ключи (foreign keys) с каскадным действием;
- проверки (checks).
Основной упор сделан на ANSI SQL.
В процессе разработки был исключён PostgreSQL как наименее
соотвествующий ANSI стандартам СУРБД в веб-среде.



CSS, JS, SASS, LESS
=====================================================================

Единая точка входа (single entry point) даёт возможность системе
контролировать процесс выдачи содержимого любого файла, благодаря чему
стало возможным использование внешних переменных в CSS и JS файлах.
Такие переменные начинаются с "%%_", а содержащие их файлы имеют
расширения *.cssd и *.jsd.

Проект не реализует и считает технологию потокового сжатия CSS и JS
устаревшей в силу следующих причин:
- сжатию подвергаются текстовые файлы в объёме от 1 до 10 килобайт,
  что при современной скорости передачи данных не существенно,
  при этом на сжатие затрачиваются ресурсы веб-сервера,
  а на распаковку - клиента (что в итоге сказывается и на заряде
  батарей мобильных клиентов);
- для CSS объём файла выше 10 килобайт считает следствием неправильного
  каскадирования стилей, вкупе с использованием такой пагубной технологии
  как SASS или LESS, потворствующей "бракодированию";
- JS файлы могут быть сжаты и обфусцированы изначально путем редукционной
  реорганизации JS кода сторонними программами или сервисами.
Однако никто не мешает использовать возможности потокового сжатия
непосредственно веб-сервера.


Событийная модель
=====================================================================

Событийная модель построена достаточно прозрачно и предсказуемо.
Достаточно зарегистрировать новое событие в events.data своего модуля,
указать его вес и обработчик в PHP коде, сбросить кэш и событие
начнёт обрабатываться. На странице "NoSQL данные → События" можно
просмотреть все зарегистрированные в системе события.
Теперь можно забыть про всякие "хуки" и неявные определения
обработчиков событий по именам обрабатывающих их функций.




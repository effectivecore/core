

                       ○○○○   ○○○○
                     ○○○○○  ○○○○○○
                    ○○○    ○○○
        ○○○○○○○     ○○○○○○○○○○○○○○  ○○○○○○○      ○○○○○○○     ○○ ○○○   ○○○○○○○
      ○○○○   ○○○○   ○○○○○○○○○○○○  ○○○     ○○○  ○○○     ○○○   ○○○    ○○○     ○○○
     ○○○       ○○○  ○○○    ○○○   ○○           ○○         ○○  ○○    ○○         ○○
    ○○○○○○○○○○○○○○  ○○○    ○○○  ○○           ○○           ○○ ○○   ○○○○○○○○○○○○○○
     ○○○            ○○○    ○○○   ○○           ○○         ○○  ○○    ○○
      ○○○○   ○○○○   ○○○    ○○○    ○○○     ○○○  ○○○     ○○○   ○○     ○○○     ○○○
        ○○○○○○○     ○○○    ○○○      ○○○○○○○      ○○○○○○○     ○○       ○○○○○○○
                  ○○○○   ○○○○
                ○○○○   ○○○○


О проекте
=====================================================================

Тип                 : система управления содержимым
Автор               : Рысевец Максим Владимирович
Разработчик         : Рысевец Максим Владимирович
Первый выпуск       : 01.01.2020
Написан на          : PHP
Операционная система: macOS, UNIX, Linux, Microsoft Windows
Лицензия            : проприетарное программное обеспечение
Сайт                : http://effcore.com

effcore - система нового поколения, разработанная в начале 20-ых годов.
Вобрала в себя все новые технологии Web 2.0/3.0 включая HTML5, CSS3, JS ES6,
IP v6, SVG, SMIL, UTF8, UTC.

Целевое назначение - использование в качестве инструмента для построения
сайтов простыми пользователями, а также в качестве инструмента для
разработки сайтов и порталов профессиональными веб-разработчиками.

Была разработана с нуля. Её главный принцип - полное отсутствие
стороннего кода (для исключения правовых претензий, а также любых
других ограничений, связанных с заимствованием),
а также сторонних идей (для поиска новых инновационных решений).

Толчком к созданию системы послужила массовая деградация в развитии
OpenSource проектов. Если рассмотреть данную ситуацию, то можно увидеть,
что разработчиками таких проектов являются люди разного уровня подготовки,
расположенные в разных частях планеты. Несогласованность в их действиях, а
также разные взгляды на решения в проекте является лишь частью проблемы.
Второй существенный недостаток - это экстенсивный путь развития кода таких
проектов в противовес интенсивному, т.е. вместо того, чтобы создавать
собственный код, они, как правило, берут очередную библиотеку, написанную
непонятно кем и непонятно где и пытаются совместить её с группой таких же
библиотек, никак между собой не согласованных и имеющих, как правило,
избыточный и не до конца протестированный функционал.
Как следствие, в результате получается набор непонятных и
не согласованных библиотек с плохо протестированным избыточным
функционалом, который постоянно растет в объёме.
К сожалению многие разработчики "погрязли" в таком коде
и пытаются отрицать очевидные вещи.

Управление содержимым в системе ориентировано на прямую (inline) вставку
любого доступного блока (меню, текст, формы, хлебные крошки и другие)
непосредственно в макет редактируемой страницы. При создании новой страницы
пользователю предоставляется выбор макета и каждая новая страница может иметь
свой уникальный дизайн и расположение блоков.

Основной упор в системе сделан на получение максимальной производительности.
В качестве оценочных критериев было принято простое и понятное условие:
система, установленная на хостинге с самым дешёвым тарифным планом,
но соответствующего минимальным требованиям установки (от ≈3$ в месяц),
должна генерировать главную страницу за время 0,002 секунды (с включенным
OPcache) или 0,02 секунды (с выключенным OPcache), что в первом случае
позволяет обслуживать до ≈500 клиентов в секунду, а во втором до ≈50 (без
учёта параллельной загрузки подключаемых файлов).

Архитектура выполнена по классической схеме MVC.
В тоже время является гибридной системой из NoSQL и SQL хранилищ и набора
классов/классов-паттернов.

Код системы адаптирован под повторное использование.
Система состоит из множества маленьких классов/классов-паттернов,
содержащих в себе в среднем от 3 до 15 методов,
состоящих в среднем из 3-7 строк кода.

Благодаря "матричному" стилю вёрстки кода его восприятие существенно
облегчается (в некоторых местах напоминает синтаксис Python), а
грамотное расположение файлов в системе позволяет определить их
назначение не прибегая к какой либо документации (в каждом модуле
всё необходимое для frontend разработки хранится в директории frontend,
а для backend разработки - в директории backend).
Также всё, что казалось сложным, было отвергнуто или переделано.
Каждая функция итеративно совершенствовалась от 3 до 10 раз.
Функциональное тестирование выполнялось на всём множестве
комбинаторных перестановок.

Имеет встроенный парсер и загрузчик классов PSR-0, благодаря чему
для добавления новой библиотеки (набора классов) достаточно поместить
содержащие их файлы на веб-сервер и сбросить кэш, после чего они
становятся доступными из любого места системы.
В состав системы входит страница с UML диаграммой всех классов
и ссылкой для загрузки JSON файла с описанием классов в формате
программы StarUML.


Безопасность
---------------------------------------------------------------------

Также немаловажным фактором в системе стала безопасность.
В качестве решений для повышения уровня безопасности были использованы:
- возможность работы без JS;
- подписанные ключом пользовательские сессии;
- подписанные ключом валидационные идентификаторы формы;
- использование препарированных SQL запросов;
- фильтрация данных, вводимых пользователем в поля формы;
- фильтрация аргументов URL;
- единая точка входа любого http запроса (single entry point),
  как результат - отсутсвие негативных воздействий при неверной настройке
  веб-сервера (.htaccess, web.config);
- возможность создания нового типа файла с полным контролем доступа;
- возможность получения хеша сборки страницы в консоле системы;
- базовый модуль CAPTCHA.

Детерминизм в работе системы - еще один немаловажный фактор.
При одних и тех же входных параметрах должен выдавать один и тот же результат
вне зависимости от платформы и как результат - полный отказ от функций,
работа которых зависит от окружения (например, setlocale и другие).


Ядро: NoSQL
---------------------------------------------------------------------

Все данные хранятся в виде PHP кода.
Возможно, самое быстрое хранилище после "хранилища в оперативной памяти".
После организации диска в оперативной памяти вы можете увеличить
производительность в 3-5 раз. Каждый подкаталог хранилища будет
инициализироваться лишь по требованию.

Любой экземпляр класса и другие NoSQL данные могут быть описаны
в текстовом формате в файле вида *.data, подобном YAML, однако
имеющем более строгие правила такие как "каждая строка может
содержать только одну фразу вида "ключ: значение".

Это удобно для контроля изменений в коде - любое изменение одного
ключа или значения будет выделяться в "git diff" только одной строкой.
Также такой формат существенно ускоряет парсинг файлов.

Ниже приведён пример *.data файла.

    demo
      object_1|class_name
        property_1: value 1
        property_2: value 2 …
        property_N: value N
      array_1
      - item_1: value 1
      - item_2: value 2 …
      - item_N: value N

При этом и объекты (экземпляры классов-паттернов) и массивы могут иметь
любые уровни вложенности и содержать в себе любые другие объекты или
массивы.

После парсинга *.data файлов результат преобразуется
в PHP код (единое дерево объектов - экземпляров классов-паттернов),
после чего сохраняется в файлы dynamic/cache/cache-*.php
раздельно для каждого вида сущности, как показано в примере ниже:
- dynamic/cache/data--blocks.php
- dynamic/cache/data--breadcrumbs.php
- dynamic/cache/data--file_types.php
и так далее.

Описанный выше пример будет преобразован в PHP файл следующего вида:

    namespace effcore {
      cache::$data['demo'] = new \stdClass;
      cache::$data['demo']->object_1 = new class_name;
      cache::$data['demo']->object_1->property_1 = 'value 1';
      cache::$data['demo']->object_1->property_2 = 'value 2';
      cache::$data['demo']->object_1->property_N = 'value N';
      cache::$data['demo']->array_1['item_1'] = 'value 1';
      cache::$data['demo']->array_1['item_2'] = 'value 2';
      cache::$data['demo']->array_1['item_N'] = 'value N';
    }

Такая архитектура позволяет получать доступ к NoSQL данным настолько быстро,
насколько это возможно. При использовании PHP модуля OPcache скорость доступа
может возрасти от 2 до 3 раз. По сути для доступа к NoSQL данным достаточно
загрузить PHP файл определенной сущности и данные станут доступны сразу же
после загрузки.

Таким образом ядро системы составляет вышеупомянутый набор классов-паттернов
и NoSQL хранилище, кэш которого представлен в виде PHP кода,
содержащего экземпляры этих классов в древовидной форме с любым уровнем
вложенности и неограниченных по своей структуре.

Изменять структуру NoSQL данных можно только со стороны PHP кода.
Например, главное меню расположено в NoSQL хранилище и пользователь не может
нарушить его работу. Меню анонимного пользователя хранится в SQL
хранилище и пользователь может редактировать данное меню через
интерфейс системы.

Поддерживаются типы полей:
- integer;
- float;
- boolean;
- string;
- array;
- object|class_name;
- null.


Ядро: SQL
---------------------------------------------------------------------

В качестве SQL хранилища могут быть использованы MySQL и SQLite.
Требуемые версии можно узнать в файле readme/software.md.
Подключение к хранилищу и выборка данных осуществляется лишь по требованию.
Отказ в доступе к SQL хранилищу не приведет к выдаче ошибки, а лишь сделает
недоступными часть возможностей (например, отключатся сессии и вход в
систему, а на страницах с выборками будет показано "0 результатов").

Поддерживаются:
- проверки (checks);
- препарированные запросы (нет шансов для SQL-инъекций);
- транзакции (begin, roll_back, commit);
- сравнения (nocase, binary);
- ограничения (primary, unique, foreign с каскадным действием);
- простые и уникальные индексы (index, unique index);
- подключение к удалённым хранилищам через процесс ручной инициализации;
- префиксы таблиц.

Поддержка каскадных действий внешнего ключа:
- на обновление: "cascade" (не протестированная возможность: "restrict", "no action");
- на   удаление: "cascade" (не протестированная возможность: "restrict", "no action").

Поддерживаются кроссплатформенные типы полей:
- autoincrement;
- varchar;
- integer;
- real;
- time;
- date;
- datetime;
- boolean (как integer: 0|1);
- blob.

Другие типы допускаются, но не протестированы.
Список протестированных типов достаточен для большинства задач.
Рекомендуется использовать только протестированные типы
для обеспечения кросс-платформенной совместимости.
Распределённые запросы к удалённым хранилищам не поддерживаются.

Основной упор сделан на ANSI SQL.
В процессе разработки был исключён PostgreSQL как СУРБД в веб-среде
наименее соответствующий ANSI стандартам.

Было принято решение не использовать поле типа timestamp.
Вместо него рекомендуется использовать поле типа datetime.
Данное поле имеет больший диапазон допустимых значений (от "0000-01-01"
до "9999-12-31"), а также не зависит от часового пояса.
При добавлении данных на сервер, даты следует
преобразовывать к часовому поясу UTC±0:00.
Вместо оригинального типа timestamp рекомендуется
использовать тип integer.


CSS, JS, SASS, LESS
---------------------------------------------------------------------

Единая точка входа (single entry point) даёт возможность системе
контролировать процесс выдачи содержимого любого файла, благодаря чему
стало возможным использование внешних переменных в CSS и JS файлах.
Такие переменные начинаются с "%%_", а содержащие их файлы имеют
расширения *.cssd и *.jsd.

Проект не реализует и считает технологию потокового сжатия CSS и JS
устаревшей в силу следующих причин:
- сжатию подвергаются текстовые файлы в объёме от 1 до 10 КиБ,
  что при современной скорости передачи данных не существенно,
  при этом на сжатие затрачиваются ресурсы веб-сервера,
  а на распаковку - клиента (что в итоге сказывается и на заряде
  батарей мобильных клиентов);
- для CSS объём файла выше 10 КиБ считает следствием неправильного
  каскадирования стилей, вкупе с использованием такой пагубной технологии
  как SASS или LESS, потворствующей "бракокодированию";
- JS файлы могут быть сжаты и обфусцированы изначально путем редукционной
  реорганизации JS кода сторонними программами или сервисами.
Однако никто не мешает использовать возможности потокового сжатия
непосредственно веб-сервера.


Событийная модель
---------------------------------------------------------------------

Событийная модель построена достаточно прозрачно и предсказуемо.
Достаточно зарегистрировать новое событие в events.data своего модуля,
указать его вес и обработчик в PHP коде, сбросить кэш и событие
начнёт обрабатываться. На странице "NoSQL данные → События" можно
просмотреть все зарегистрированные в системе события.
Теперь можно забыть про "хуки" и неявные определения обработчиков
событий по именам обрабатывающих их функций.


Веб-сервер
---------------------------------------------------------------------

В качестве веб-сервера поддерживаются Apache, NGINX, IIS.
Требуемые версии можно узнать в файле readme/software.md.


Кэширование
---------------------------------------------------------------------

Благодаря своей архитектуре в проектах среднего уровня не требуется кэширование.
Для больших проектов кэширование обычно выполняется сторонними средствами
веб-сервера, что изначально предполагается автором.


Лицензирование
---------------------------------------------------------------------

Система является открытой и бесплатной.
Система не является общественным достоянием.
Любой желающий на основе неё может создать сайт, портал или
сервис как себе лично, так и любому заказчику.
Однако нельзя распространять файлы системы в исходном или
изменённом виде либо совместно с чем либо ещё.


